#pragma once
#include <initializer_list>
#include <set>
#include <tsl/robin_map.h>

#include "../types.hpp"

namespace reneu{

using Segid2VoxelNum = tsl::robin_map<segid_t, size_t>;

inline auto get_segid_to_voxel_num(const Segmentation& seg){
    Segid2VoxelNum id2count;

    for(const auto& segid : seg){
        if(segid>0)
            ++id2count[segid];
    }
    return id2count;
}

inline auto get_nonzero_segids(const PySegmentation& seg){
    
    std::set<segid_t> segids = {};
    for(const auto& segid : seg){
        if(segid>0)
            segids.insert(segid);
    }

    return segids;
}

auto get_label_map(const PySegmentation& frag, const PySegmentation& seg){
    tsl::robin_map<segid_t, segid_t> labelMap = {};

    for(std::size_t idx = 0; idx < frag.size(); idx ++){
        const auto& sid0 = frag(idx);
        const auto& sid1 = seg(idx);
        if(sid0!=sid1 && sid0>0){
            labelMap[sid0] = sid1;
        }
    }

    xt::xtensor<segid_t, 2>::shape_type sh = {labelMap.size(), 2};
    auto labelMapArray = xt::empty<segid_t>(sh);
    std::size_t idx = 0;
    for(const auto& [sid0, root]: labelMap){
        labelMapArray(idx, 0) = sid0;
        labelMapArray(idx, 1) = root;
        idx ++;
    }

    return labelMapArray;
}


using SegPairs = std::vector<std::pair<segid_t, segid_t>>;
auto seg_pairs_to_array(SegPairs& pairs){
    // std::cout<<"convert to array."<<std::endl;
    const auto& pairNum = pairs.size();
    xt::xtensor<segid_t, 2>::shape_type sh = {pairNum, 2};
    auto arr = xt::empty<segid_t>(sh);
    for(std::size_t idx=0; idx<pairNum; idx++){
        const auto& [segid0, root] = pairs[idx];
        arr(idx, 0) = segid0;
        arr(idx, 1) = root;
        // std::cout<<"merge "<<segid0<<", "<<root<<std::endl;
    }
    return arr;
}

/**
 * @brief given a fragment array and plain segmentation, find the disjoint sets. 
 * 
 * @param frag The fragment segmentation containing super voxels.
 * @param seg The plain segmentation generated by agglomerating framgents
 * @return The corresponding object pairs that need to be merged 
 */
auto agglomerated_segmentation_to_merge_pairs(const PySegmentation& frag, const PySegmentation& seg){
    assert(frag.shape(0) == seg.shape(0));
    assert(frag.shape(1) == seg.shape(1));
    assert(frag.shape(2) == seg.shape(2));

    SegPairs pairs = {};
    // auto dsets = DisjointSets();
    // for(const auto& obj: frag){
    //     if(obj > 0) dsets.make_set(obj);
    // }
    
    for(std::ptrdiff_t z=0; z<seg.shape(0); z++){
        for(std::ptrdiff_t y=0; y<seg.shape(1); y++){
            for(std::ptrdiff_t x=0; x<seg.shape(2); x++){
                const auto& obj0 = frag(z, y, x);
                if(z>0){
                    const auto& obj1 = frag(z-1, y, x);
                    if(obj0!=obj1 && seg(z,y,x)==seg(z-1,y,x) && obj0>0 && obj1>0){
                        // std::cout<<"merge :"<<obj0<<", "<<obj1<<std::endl;
                        // dsets.make_and_union_set(obj0, obj1);
                        pairs.emplace_back(obj0, obj1);
                    }
                }

                if(y>0){
                    const auto& obj1 = frag(z,y-1,x);
                    if(obj0!=obj1 && seg(z,y,x)==seg(z,y-1,x) && obj0>0 && obj1>0){
                        // std::cout<<"merge :"<<obj0<<", "<<obj1<<std::endl;
                        // dsets.make_and_union_set(obj0, obj1);
                        pairs.emplace_back(obj0, obj1);
                    }
                }

                if(x>0){
                    const auto& obj1 = frag(z, y, x-1);
                    if(obj0!=obj1 && seg(z,y,x)==seg(z,y,x-1) && obj0>0 && obj1>0){
                        // std::cout<<"merge :"<<obj0<<", "<<obj1<<std::endl;
                        // dsets.make_and_union_set(obj0, obj1);
                        pairs.emplace_back(obj0, obj1);
                    }
                }
            }
        }
    }

    std::cout<<"transform to array."<<std::endl;
    auto arr = seg_pairs_to_array(pairs);

    return arr;
}

} // namespace reneu