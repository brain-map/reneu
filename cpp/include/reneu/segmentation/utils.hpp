#pragma once
#include <initializer_list>
#include <set>
#include <map>
#include <tsl/robin_map.h>

#include "../type_aliase.hpp"

namespace reneu{

using Segid2VoxelNum = tsl::robin_map<segid_t, size_t>;

inline auto get_segid_to_voxel_num(const Segmentation& seg){
    Segid2VoxelNum id2count;

    for(const auto& segid : seg){
        if(segid>0)
            ++id2count[segid];
    }
    return id2count;
}

inline auto get_nonzero_segids(const Segmentation& seg){
    
    std::set<segid_t> segids = {};
    for(const auto& segid : seg){
        if(segid>0)
            segids.insert(segid);
    }

    return segids;
}

/**
 * @brief given a fragment array and plain segmentation, find the fragment objct IDS that need to be agglomerated. 
 * 
 * @param frag The fragment segmentation containing super voxels.
 * @param seg The plain segmentation generated by agglomerating framgents
 * @return The mapping from fragment object id to plain segmentation id
 */
auto fragment_id_map(const PySegmentation& frag, const PySegmentation& seg){
    std::map<segid_t, segid_t> id_map = {};
    const auto& flat_frag = xt::flatten(frag);
    const auto& flat_seg = xt::flatten(seg);

    for(std::size_t i=0; i<seg.size(); i++){
        const auto& key = flat_frag(i);
        const auto& val = flat_seg(i);
        if(key>0 && ~id_map.contains(key)){
            id_map[key] = val;
        }
    }

    return id_map;
}
} // namespace reneu