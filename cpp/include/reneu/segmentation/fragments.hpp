#pragma once

#include "../types.hpp"
#include "disjoint_sets.hpp"

namespace reneu{

/**
 * @brief given a fragment array and plain segmentation, find the disjoint sets. 
 * 
 * @param frag The fragment segmentation containing super voxels.
 * @param seg The plain segmentation generated by agglomerating framgents
 * @return The corresponding object pairs that need to be merged 
 */
auto agglomerated_segmentation_to_merge_pairs(
        const PySegmentation& frag, 
        const PySegmentation& seg){
    assert(frag.shape(0) == seg.shape(0));
    assert(frag.shape(1) == seg.shape(1));
    assert(frag.shape(2) == seg.shape(2));

    // SegPairs pairs = {};
    auto dsets = DisjointSets<segid_t>();
    for(const auto& obj: frag){
        if(obj > 0) dsets.make_set(obj);
    }
    
    for(std::ptrdiff_t z=0; z<seg.shape(0); z++){
        for(std::ptrdiff_t y=0; y<seg.shape(1); y++){
            for(std::ptrdiff_t x=0; x<seg.shape(2); x++){
                const auto& obj0 = frag(z, y, x);
                if(z>0){
                    const auto& obj1 = frag(z-1, y, x);
                    if(obj0!=obj1 && seg(z,y,x)==seg(z-1,y,x) && obj0>0 && obj1>0){
                        // std::cout<<"merge :"<<obj0<<", "<<obj1<<std::endl;
                        dsets.union_set(obj0, obj1);
                        // pairs.emplace_back(obj0, obj1);
                    }
                }

                if(y>0){
                    const auto& obj1 = frag(z,y-1,x);
                    if(obj0!=obj1 && seg(z,y,x)==seg(z,y-1,x) && obj0>0 && obj1>0){
                        // std::cout<<"merge :"<<obj0<<", "<<obj1<<std::endl;
                        dsets.union_set(obj0, obj1);
                        // pairs.emplace_back(obj0, obj1);
                    }
                }

                if(x>0){
                    const auto& obj1 = frag(z, y, x-1);
                    if(obj0!=obj1 && seg(z,y,x)==seg(z,y,x-1) && obj0>0 && obj1>0){
                        // std::cout<<"merge :"<<obj0<<", "<<obj1<<std::endl;
                        dsets.union_set(obj0, obj1);
                        // pairs.emplace_back(obj0, obj1);
                    }
                }
            }
        }
    }

    std::cout<<"transform to array."<<std::endl;
    // auto arr = seg_pairs_to_array(pairs);
    const auto& arr = dsets.to_array();

    return arr;
}

} // namespace reneu